"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("./util");
var BISTATE = Symbol('BISTATE');
exports.isBistate = function (input) { return !!(input && input[BISTATE]); };
var getBistateValue = function (value, currentProxy, previousProxy) {
    if (previousProxy && exports.isBistate(value)) {
        var parent_1 = value[BISTATE].getParent();
        // reuse bistate
        if (parent_1 === previousProxy) {
            value = value[BISTATE].compute();
        }
        else {
            value = createBistate(value);
        }
    }
    else if (util_1.isArray(value) || util_1.isObject(value)) {
        value = createBistate(value);
    }
    if (exports.isBistate(value)) {
        value[BISTATE].setParent(currentProxy);
    }
    return value;
};
var fillObjectBistate = function (currentProxy, initialObject, target, scapegoat, previousProxy) {
    for (var key in initialObject) {
        var value = getBistateValue(initialObject[key], currentProxy, previousProxy);
        scapegoat[key] = value;
        target[key] = value;
    }
};
var fileArrayBistate = function (currentProxy, initialArray, target, scapegoat, previousProxy) {
    for (var i = 0; i < initialArray.length; i++) {
        var item = getBistateValue(initialArray[i], currentProxy, previousProxy);
        scapegoat[i] = item;
        target[i] = item;
    }
};
var isMutable = false;
var dirtyStateList = [];
exports.mutate = function (f) {
    if (!util_1.isFunction(f)) {
        throw new Error("Expected f in mutate(f) is a function, but got " + f + " ");
    }
    var previousFlag = isMutable;
    isMutable = true;
    f();
    if (previousFlag)
        return;
    var list = dirtyStateList;
    isMutable = false;
    dirtyStateList = [];
    for (var i = 0; i < list.length; i++) {
        var item = list[i];
        item[BISTATE].trigger();
    }
};
var createBistate = function (initialState, previousProxy) {
    if (previousProxy === void 0) { previousProxy = null; }
    if (!util_1.isArray(initialState) && !util_1.isObject(initialState)) {
        throw new Error("Expected initialState to be array or plain object, but got " + initialState);
    }
    var scapegoat = util_1.isArray(initialState) ? [] : {};
    var target = util_1.isArray(initialState) ? [] : {};
    var consuming = false;
    var watcher = null;
    var watch = function (f) {
        if (watcher)
            throw new Error("bistate can be watched twice");
        if (!scapegoat)
            throw new Error("current state is immutable, can not be watched now");
        if (parent)
            throw new Error("Only root node can be watched");
        watcher = f;
        if (isDirty) {
            trigger();
        }
        else {
            consuming = true;
        }
        return unwatch;
    };
    var unwatch = function () {
        consuming = false;
        watcher = null;
    };
    var parent = null;
    var setParent = function (input) {
        parent = input;
    };
    var getParent = function () {
        return parent;
    };
    var deleteParent = function () {
        parent = null;
    };
    var isDirty = false;
    var notify = function () {
        isDirty = true;
        if (consuming && !dirtyStateList.includes(currentProxy)) {
            dirtyStateList.push(currentProxy);
        }
        if (parent) {
            parent[BISTATE].notify();
        }
    };
    var trigger = function () {
        if (!watcher)
            return;
        var f = watcher;
        var nextProxy = compute();
        if (nextProxy !== currentProxy) {
            f(nextProxy);
        }
    };
    var compute = function () {
        if (!isDirty)
            return currentProxy;
        /**
         * redo
         * create nextProxy based on scapegoat and currentProxy
         * reuse unchanged value as possible
         */
        var nextProxy = createBistate(scapegoat, currentProxy);
        /**
         * undo
         * clear scapegoat to keep currentProxy as immutable
         */
        scapegoat = null;
        deleteParent();
        unwatch();
        return nextProxy;
    };
    var internal = { watch: watch, setParent: setParent, getParent: getParent, deleteParent: deleteParent, notify: notify, compute: compute, trigger: trigger };
    var handlers = {
        get: function (target, key) {
            if (key === BISTATE)
                return internal;
            if (isMutable && scapegoat) {
                return Reflect.get(scapegoat, key);
            }
            else {
                return Reflect.get(target, key);
            }
        },
        set: function (_, key, value) {
            if (isMutable && scapegoat) {
                var result = Reflect.set(scapegoat, key, value);
                notify();
                return result;
            }
            else {
                throw new Error("state is immutable, it's not allow to set property " + key);
            }
        },
        deleteProperty: function (_, key) {
            if (isMutable && scapegoat) {
                var result = Reflect.deleteProperty(scapegoat, key);
                notify();
                return result;
            }
            else {
                throw new Error("state is immutable, it's not allow to delete property " + key);
            }
        },
        has: function (target, key) {
            if (isMutable && scapegoat) {
                return Reflect.has(scapegoat, key);
            }
            else {
                return Reflect.has(target, key);
            }
        },
        ownKeys: function (target) {
            if (isMutable && scapegoat) {
                return Reflect.ownKeys(scapegoat);
            }
            else {
                return Reflect.ownKeys(target);
            }
        }
    };
    var currentProxy = new Proxy(target, handlers);
    if (util_1.isArray(currentProxy)) {
        fileArrayBistate(currentProxy, initialState, target, scapegoat, previousProxy);
    }
    else {
        fillObjectBistate(currentProxy, initialState, target, scapegoat, previousProxy);
    }
    // clear previousProxy
    previousProxy = null;
    // clear initialState
    initialState = null;
    return currentProxy;
};
function default_1(initialState) {
    return createBistate(initialState, null);
}
exports.default = default_1;
exports.watch = function (state, watcher) {
    if (!exports.isBistate(state)) {
        throw new Error("Expected state to be a bistate, but received " + state);
    }
    if (!util_1.isFunction(watcher)) {
        throw new Error("Expected watcher to be a function, but received " + watcher);
    }
    return state[BISTATE].watch(watcher);
};
exports.remove = function (state) {
    if (!exports.isBistate(state)) {
        throw new Error("Expected state to be a bistate, but received " + state);
    }
    var parent = state[BISTATE].getParent();
    if (!parent)
        return;
    exports.mutate(function () {
        if (util_1.isArray(parent)) {
            var index = parent.indexOf(state);
            parent.splice(index, 1);
            return;
        }
        if (util_1.isObject(parent)) {
            for (var key in parent) {
                var value = parent[key];
                if (value === state) {
                    delete parent[key];
                    return;
                }
            }
        }
    });
};
//# sourceMappingURL=createBistate.js.map